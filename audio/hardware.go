package audio

const (
	SampleRate = 96000
)

const (
	lookupCount = 32
	waveCount   = 8
	volumeCount = 16
	voiceCount  = 3

	maxVolume    = volumeCount - 1
	maxValue     = 0xf
	encodedRange = 0xffff
	encodedZero  = 0x8000
)

var waveData = [waveCount][lookupCount]byte{
	{0x7, 0x9, 0xa, 0xb, 0xc, 0xd, 0xd, 0xe, 0xe, 0xe, 0xd, 0xd, 0xc, 0xb, 0xa, 0x9, 0x7, 0x5, 0x4, 0x3, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x2, 0x3, 0x4, 0x5},
	{0x7, 0xc, 0xe, 0xe, 0xd, 0xb, 0x9, 0xa, 0xb, 0xb, 0xa, 0x9, 0x6, 0x4, 0x3, 0x5, 0x7, 0x9, 0xb, 0xa, 0x8, 0x5, 0x4, 0x3, 0x3, 0x4, 0x5, 0x3, 0x1, 0x0, 0x0, 0x2},
	{0x7, 0xa, 0xc, 0xd, 0xe, 0xd, 0xc, 0xa, 0x7, 0x4, 0x2, 0x1, 0x0, 0x1, 0x2, 0x4, 0x7, 0xb, 0xd, 0xe, 0xd, 0xb, 0x7, 0x3, 0x1, 0x0, 0x1, 0x3, 0x7, 0xe, 0x7, 0x0},
	{0x7, 0xd, 0xb, 0x8, 0xb, 0xd, 0x9, 0x6, 0xb, 0xe, 0xc, 0x7, 0x9, 0xa, 0x6, 0x2, 0x7, 0xc, 0x8, 0x4, 0x5, 0x7, 0x2, 0x0, 0x3, 0x8, 0x5, 0x1, 0x3, 0x6, 0x3, 0x1},
	{0x0, 0x8, 0xf, 0x7, 0x1, 0x8, 0xe, 0x7, 0x2, 0x8, 0xd, 0x7, 0x3, 0x8, 0xc, 0x7, 0x4, 0x8, 0xb, 0x7, 0x5, 0x8, 0xa, 0x7, 0x6, 0x8, 0x9, 0x7, 0x7, 0x8, 0x8, 0x7},
	{0x7, 0x8, 0x6, 0x9, 0x5, 0xa, 0x4, 0xb, 0x3, 0xc, 0x2, 0xd, 0x1, 0xe, 0x0, 0xf, 0x0, 0xf, 0x1, 0xe, 0x2, 0xd, 0x3, 0xc, 0x4, 0xb, 0x5, 0xa, 0x6, 0x9, 0x7, 0x8},
	{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0},
	{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf},
}

var scaledWaveData [volumeCount][waveCount][lookupCount]uint16

func init() {
	// precalculate the wave data for each possible volume level
	for volume := range 16 {
		for wave := range waveData {
			for index, value := range waveData[wave] {
				scaled := uint32(value) * uint32(volume) * uint32(encodedRange) / (maxValue * maxVolume * voiceCount)
				scaledWaveData[volume][wave][index] = encodedZero + uint16(scaled)
			}
		}
	}
}

type HwVoice struct {
	wave byte   // low 3 bits used – selects waveform 0-7 from ROM
	vol  byte   // low nibble – 0 off to 15 loudest
	freq uint32 // real hardware has 20 bits for voice 0; 16 bits voices 1, 2
}

type Audio struct {
	voices        [voiceCount]HwVoice
	pos           int64
	nextFrameTime float64
}

func NewAudio() *Audio {
	return &Audio{}
}

// Read is io.Reader's Read.
//
// Read fills the data with sine wave samples.
func (s *Audio) Read(buf []byte) (int, error) {
	const (
		bytesPerValue  = 2
		bytesPerSample = bytesPerValue * 2 // 2 16-bit samples (for left and right)
	)

	alignedLen := len(buf) / bytesPerSample * bytesPerSample

	numSamples := alignedLen / bytesPerSample
	numEmitted := s.pos / bytesPerSample

	// sample and mix channels
	for i := range numSamples {
		sampleIndex := float64(numEmitted + int64(i))
		t := sampleIndex / SampleRate

		// schedule the sequencer every 1/60s
		if t >= s.nextFrameTime {
			s.nextFrameTime = t + 1.0/60.0
			runSequencerFrame()
		}

		var v16 uint16
		for _, channel := range hw_voice {
			j := int(lookupCount*float64(channel.freq)/2*t) % lookupCount
			v16 += scaledWaveData[channel.vol][channel.wave][j]
		}

		buf[4*i] = byte(v16)
		buf[4*i+1] = byte(v16 >> 8)
		buf[4*i+2] = byte(v16)
		buf[4*i+3] = byte(v16 >> 8)
	}

	s.pos += int64(alignedLen)

	return alignedLen, nil
}

// Close is io.Closer's Close.
func (s *Audio) Close() error {
	return nil
}

// TODO unused
func (s *Audio) SetVolume(channel int, volume int) {
	hw_voice[channel].vol = byte(volume)
}
func (s *Audio) SetFreq(channel int, freq int) {
	hw_voice[channel].freq = uint32(freq)
}
func (s *Audio) SetWave(channel int, wave int) {
	hw_voice[channel].wave = byte(wave)
}

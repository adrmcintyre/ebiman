package audio

const (
	lookupCount  = 32
	waveCount    = 8
	maxWaveValue = 0xf
)

var waveData = [waveCount][lookupCount]byte{
	{0x7, 0x9, 0xa, 0xb, 0xc, 0xd, 0xd, 0xe, 0xe, 0xe, 0xd, 0xd, 0xc, 0xb, 0xa, 0x9, 0x7, 0x5, 0x4, 0x3, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x2, 0x3, 0x4, 0x5},
	{0x7, 0xc, 0xe, 0xe, 0xd, 0xb, 0x9, 0xa, 0xb, 0xb, 0xa, 0x9, 0x6, 0x4, 0x3, 0x5, 0x7, 0x9, 0xb, 0xa, 0x8, 0x5, 0x4, 0x3, 0x3, 0x4, 0x5, 0x3, 0x1, 0x0, 0x0, 0x2},
	{0x7, 0xa, 0xc, 0xd, 0xe, 0xd, 0xc, 0xa, 0x7, 0x4, 0x2, 0x1, 0x0, 0x1, 0x2, 0x4, 0x7, 0xb, 0xd, 0xe, 0xd, 0xb, 0x7, 0x3, 0x1, 0x0, 0x1, 0x3, 0x7, 0xe, 0x7, 0x0},
	{0x7, 0xd, 0xb, 0x8, 0xb, 0xd, 0x9, 0x6, 0xb, 0xe, 0xc, 0x7, 0x9, 0xa, 0x6, 0x2, 0x7, 0xc, 0x8, 0x4, 0x5, 0x7, 0x2, 0x0, 0x3, 0x8, 0x5, 0x1, 0x3, 0x6, 0x3, 0x1},
	{0x0, 0x8, 0xf, 0x7, 0x1, 0x8, 0xe, 0x7, 0x2, 0x8, 0xd, 0x7, 0x3, 0x8, 0xc, 0x7, 0x4, 0x8, 0xb, 0x7, 0x5, 0x8, 0xa, 0x7, 0x6, 0x8, 0x9, 0x7, 0x7, 0x8, 0x8, 0x7},
	{0x7, 0x8, 0x6, 0x9, 0x5, 0xa, 0x4, 0xb, 0x3, 0xc, 0x2, 0xd, 0x1, 0xe, 0x0, 0xf, 0x0, 0xf, 0x1, 0xe, 0x2, 0xd, 0x3, 0xc, 0x4, 0xb, 0x5, 0xa, 0x6, 0x9, 0x7, 0x8},
	{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0},
	{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf},
}

var scaledWaveData [volumeCount][waveCount][lookupCount]uint16

func init() {
	// precalculate the wave data for each possible volume level
	for volume := range 16 {
		for wave := range waveData {
			for index, value := range waveData[wave] {
				scaled := uint32(value) * uint32(volume) * uint32(encodedRange) / (maxWaveValue * maxVolume * voiceCount)
				scaledWaveData[volume][wave][index] = encodedZero + uint16(scaled)
			}
		}
	}
}

package color

import (
	"github.com/hajimehoshi/ebiten/v2/colorm"
)

// A paletteEntry is a sequence of 4 bytes representing a 4-colour lookup table.
//
// Sprites and tiles are encoded as 2-bits-per-pixel bitmaps, with each possible
// value of 00, 01, 10, 11 being rendered as a colour drawn from a specified
// palette. Each location in a paletteEntry is actually a 4-bit index into the
// separate colorData table. Color 00 in the bitmaps is reserved as "transparent",
// and never interpreted in terms of colorData.
type paletteEntry [4]byte

// Format: color_index0, color_index1, color_index2, color_index3
var paletteData = [64]paletteEntry{
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0xf, 0xb, 0x1}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0xf, 0xb, 0x3}, //  0,  1,  2,  3
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0xf, 0xb, 0x5}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0xf, 0xb, 0x7}, //  4,  5,  6,  7
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0xb, 0x1, 0x9}, {0x0, 0xb, 0x1, 0xc}, {0x0, 0x0, 0x0, 0x0}, //  8,  9, 10, 11
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0xf, 0x0, 0xe}, {0x0, 0x1, 0xc, 0xf}, // 12, 13, 14, 15
	{0x0, 0xe, 0x0, 0xb}, {0x0, 0xc, 0xb, 0xe}, {0x0, 0xc, 0xf, 0x1}, {0x0, 0x0, 0x0, 0x0}, // 16, 17, 18, 19
	{0x0, 0x1, 0x2, 0xf}, {0x0, 0x7, 0xc, 0x2}, {0x0, 0x9, 0x6, 0xf}, {0x0, 0xd, 0xc, 0xf}, // 20, 21, 22, 23
	{0x0, 0x5, 0x3, 0x9}, {0x0, 0xf, 0xb, 0x0}, {0x0, 0xe, 0x0, 0xb}, {0x0, 0xe, 0x0, 0xb}, // 24, 25, 26, 27
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0xf, 0xe, 0x1}, {0x0, 0xf, 0xb, 0xe}, {0x0, 0xe, 0x0, 0xf}, // 28, 29, 30, 31

	// entries 32-63 not used
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0},
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0},
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0},
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0},
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0},
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0},
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0},
	{0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0}, {0x0, 0x0, 0x0, 0x0},
}

var (
	// ColorM contains an ebiten colour matrix corresponding to each paletteEntry.
	ColorM [64]colorm.ColorM
)

// MakeColorMatrices initialises the cache of ebiten.ColorM matrices
// corresponding to each colour palette.
//
// Fortuitously a colour matrix represents four colour channels R, G, B and A.
// We assign the 3 palette entries for 10, 01 and 11 to channels R, G and B
// respectively, and 00 to A. We then set up the matrix so that 100% R will
// render as the color corresponding to 10's color index, and similarly with
// G for 01 and B for 11. When creating full-colour RGBA ebiten bitmaps from
// the 2-bpp sources, we replace colour 10 with full-scale red, 01 with green,
// and 11 with blue. Finally when compositing the bitmaps into a display frame,
// we mix them with the colour matrix corresponding to the selected palette,
// and R, G and B are interpreted as the desired colours.
func MakeColorMatrixes() {
	for i := range 64 {
		mat := colorm.ColorM{}
		for j := range 3 {
			ci := paletteData[i][1+j]
			r, g, b := colorData[ci].toRGB()
			mat.SetElement(0, j, r)
			mat.SetElement(1, j, g)
			mat.SetElement(2, j, b)
		}
		ColorM[i] = mat
	}
}
